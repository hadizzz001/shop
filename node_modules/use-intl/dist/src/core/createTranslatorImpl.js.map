{"version":3,"sources":["../../../src/core/createTranslatorImpl.tsx"],"sourcesContent":["import AbstractIntlMessages from './AbstractIntlMessages';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport {RichTranslationValues, TranslationValue} from './TranslationValues';\nimport createBaseTranslator, {getMessagesOrError} from './createBaseTranslator';\nimport resolveNamespace from './resolveNamespace';\nimport NestedKeyOf from './utils/NestedKeyOf';\n\nexport type CoreRichTranslationValues = Record<\n  string,\n  TranslationValue | ((chunks: string) => string)\n>;\n\nexport type CreateTranslatorImplProps<Messages> = Omit<\n  InitializedIntlConfig,\n  'messages'\n> & {\n  namespace: string;\n  messages: Messages;\n};\n\nexport default function createTranslatorImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(\n  {\n    getMessageFallback,\n    messages,\n    namespace,\n    onError,\n    ...rest\n  }: CreateTranslatorImplProps<Messages>,\n  namespacePrefix: string\n) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const translator = createBaseTranslator<Messages, NestedKey>({\n    ...rest,\n    onError,\n    getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages,\n      namespace,\n      onError\n    }) as Messages | IntlError\n  });\n\n  const originalRich = translator.rich;\n\n  function base(...args: Parameters<typeof translator>) {\n    return translator(...args);\n  }\n\n  // Augment `t.rich` to return plain strings\n  base.rich = (\n    key: Parameters<typeof originalRich>[0],\n    /** Key value pairs for values to interpolate into the message. */\n    values: CoreRichTranslationValues,\n    formats?: Parameters<typeof originalRich>[2]\n  ): string => {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    const result = originalRich(key, values as RichTranslationValues, formats);\n\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      const error = new IntlError(\n        IntlErrorCode.FORMATTING_ERROR,\n        process.env.NODE_ENV !== 'production'\n          ? \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\"\n          : undefined\n      );\n\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    return result;\n  };\n\n  base.raw = translator.raw;\n\n  return base;\n}\n"],"mappings":"0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAEA,IAAAI,EAAuC,0BAEvCC,EAAuD,qCACvDC,EAA6B,iCAgBd,SAARJ,EAIL,CACE,mBAAAK,EACA,SAAAC,EACA,UAAAC,EACA,QAAAC,EACA,GAAGC,CACL,EACAC,EACA,CAGAJ,EAAWA,EAASI,CAAe,EACnCH,KAAY,EAAAI,SAAiBJ,EAAWG,CAAe,EAEvD,MAAME,KAAa,EAAAC,SAA0C,CAC3D,GAAGJ,EACH,QAAAD,EACA,mBAAAH,EACA,mBAAiB,sBAAmB,CAClC,SAAAC,EACA,UAAAC,EACA,QAAAC,CACF,CAAC,CACH,CAAC,EAEKM,EAAeF,EAAW,KAEhC,SAASG,KAAQC,EAAqC,CACpD,OAAOJ,EAAW,GAAGI,CAAI,CAC3B,CAGA,OAAAD,EAAK,KAAO,CACVE,EAEAC,EACAC,IACW,CAGX,MAAMC,EAASN,EAAaG,EAAKC,EAAiCC,CAAO,EAGzE,GAAI,OAAOC,GAAW,SAAU,CAC9B,MAAMC,EAAQ,IAAI,EAAAC,QAChB,gBAAc,iBACd,QAAQ,IAAI,WAAa,aACrB,kKACA,MACN,EAEA,OAAAd,EAAQa,CAAK,EACNhB,EAAmB,CAAC,MAAAgB,EAAO,IAAAJ,EAAK,UAAAV,CAAS,CAAC,CACnD,CAEA,OAAOa,CACT,EAEAL,EAAK,IAAMH,EAAW,IAEfG,CACT","names":["createTranslatorImpl_exports","__export","createTranslatorImpl","__toCommonJS","import_IntlError","import_createBaseTranslator","import_resolveNamespace","getMessageFallback","messages","namespace","onError","rest","namespacePrefix","resolveNamespace","translator","createBaseTranslator","originalRich","base","args","key","values","formats","result","error","IntlError"]}