{"version":3,"sources":["../../src/core/createFormatter.tsx"],"sourcesContent":["import DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport NumberFormatOptions from './NumberFormatOptions';\nimport TimeZone from './TimeZone';\nimport {defaultOnError} from './defaults';\n\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst YEAR = DAY * 365;\n\nfunction getRelativeTimeFormatConfig(seconds: number) {\n  const absValue = Math.abs(seconds);\n  let value, unit: Intl.RelativeTimeFormatUnit;\n\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n\n  if (absValue < MINUTE) {\n    unit = 'second';\n    value = Math.round(seconds);\n  } else if (absValue < HOUR) {\n    unit = 'minute';\n    value = Math.round(seconds / MINUTE);\n  } else if (absValue < DAY) {\n    unit = 'hour';\n    value = Math.round(seconds / HOUR);\n  } else if (absValue < WEEK) {\n    unit = 'day';\n    value = Math.round(seconds / DAY);\n  } else if (absValue < MONTH) {\n    unit = 'week';\n    value = Math.round(seconds / WEEK);\n  } else if (absValue < YEAR) {\n    unit = 'month';\n    value = Math.round(seconds / MONTH);\n  } else {\n    unit = 'year';\n    value = Math.round(seconds / YEAR);\n  }\n\n  return {value, unit};\n}\n\ntype Props = {\n  locale: string;\n  timeZone?: TimeZone;\n  onError?(error: IntlError): void;\n  formats?: Partial<Formats>;\n  now?: Date;\n};\n\nexport default function createFormatter({\n  formats,\n  locale,\n  now: globalNow,\n  onError = defaultOnError,\n  timeZone\n}: Props) {\n  function resolveFormatOrOptions<Options>(\n    typeFormats: Record<string, Options> | undefined,\n    formatOrOptions?: string | Options\n  ) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n\n      if (!options) {\n        const error = new IntlError(\n          IntlErrorCode.MISSING_FORMAT,\n          process.env.NODE_ENV !== 'production'\n            ? `Format \\`${formatName}\\` is not available. You can configure it on the provider or provide custom options.`\n            : undefined\n        );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n\n    return options;\n  }\n\n  function getFormattedValue<Value, Options>(\n    value: Value,\n    formatOrOptions: string | Options | undefined,\n    typeFormats: Record<string, Options> | undefined,\n    formatter: (options?: Options) => string\n  ) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(value);\n    }\n  }\n\n  function dateTime(\n    /** If a number is supplied, this is interpreted as a UTC timestamp. */\n    value: Date | number,\n    /** If a time zone is supplied, the `value` is converted to that time zone.\n     * Otherwise the user time zone will be used. */\n    formatOrOptions?: string | DateTimeFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.dateTime,\n      (options) => {\n        if (timeZone && !options?.timeZone) {\n          options = {...options, timeZone};\n        }\n\n        return new Intl.DateTimeFormat(locale, options).format(value);\n      }\n    );\n  }\n\n  function number(\n    value: number | bigint,\n    formatOrOptions?: string | NumberFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.number,\n      (options) => new Intl.NumberFormat(locale, options).format(value)\n    );\n  }\n\n  function relativeTime(\n    /** The date time that needs to be formatted. */\n    date: number | Date,\n    /** The reference point in time to which `date` will be formatted in relation to.  */\n    now?: number | Date\n  ) {\n    try {\n      if (!now) {\n        if (globalNow) {\n          now = globalNow;\n        } else {\n          throw new Error(\n            process.env.NODE_ENV !== 'production'\n              ? `The \\`now\\` parameter wasn't provided and there was no global fallback configured on the provider.`\n              : undefined\n          );\n        }\n      }\n\n      const dateDate = date instanceof Date ? date : new Date(date);\n      const nowDate = now instanceof Date ? now : new Date(now);\n\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      const {unit, value} = getRelativeTimeFormatConfig(seconds);\n\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(date);\n    }\n  }\n\n  function list(\n    value: Iterable<string>,\n    formatOrOptions?: string | Intl.ListFormatOptions\n  ) {\n    return getFormattedValue(value, formatOrOptions, formats?.list, (options) =>\n      new Intl.ListFormat(locale, options).format(value)\n    );\n  }\n\n  return {dateTime, number, relativeTime, list};\n}\n"],"mappings":"AAEA,OAAOA,GAAY,iBAAAC,MAAoB,cAGvC,OAAQ,kBAAAC,MAAqB,aAE7B,MAAMC,EAAS,GACTC,EAAOD,EAAS,GAChBE,EAAMD,EAAO,GACbE,EAAOD,EAAM,EACbE,EAAQF,GAAO,IAAM,IACrBG,EAAOH,EAAM,IAEnB,SAASI,EAA4BC,EAAiB,CACpD,MAAMC,EAAW,KAAK,IAAID,CAAO,EACjC,IAAIE,EAAOC,EAKX,OAAIF,EAAWR,GACbU,EAAO,SACPD,EAAQ,KAAK,MAAMF,CAAO,GACjBC,EAAWP,GACpBS,EAAO,SACPD,EAAQ,KAAK,MAAMF,EAAUP,CAAM,GAC1BQ,EAAWN,GACpBQ,EAAO,OACPD,EAAQ,KAAK,MAAMF,EAAUN,CAAI,GACxBO,EAAWL,GACpBO,EAAO,MACPD,EAAQ,KAAK,MAAMF,EAAUL,CAAG,GACvBM,EAAWJ,GACpBM,EAAO,OACPD,EAAQ,KAAK,MAAMF,EAAUJ,CAAI,GACxBK,EAAWH,GACpBK,EAAO,QACPD,EAAQ,KAAK,MAAMF,EAAUH,CAAK,IAElCM,EAAO,OACPD,EAAQ,KAAK,MAAMF,EAAUF,CAAI,GAG5B,CAAC,MAAAI,EAAO,KAAAC,CAAI,CACrB,CAUe,SAARC,EAAiC,CACtC,QAAAC,EACA,OAAAC,EACA,IAAKC,EACL,QAAAC,EAAUhB,EACV,SAAAiB,CACF,EAAU,CACR,SAASC,EACPC,EACAC,EACA,CACA,IAAIC,EACJ,GAAI,OAAOD,GAAoB,SAAU,CACvC,MAAME,EAAaF,EAGnB,GAFAC,EAAUF,IAAcG,CAAU,EAE9B,CAACD,EAAS,CACZ,MAAME,EAAQ,IAAIzB,EAChBC,EAAc,eACd,QAAQ,IAAI,WAAa,aACrB,YAAYuB,CAAU,uFACtB,MACN,EACA,MAAAN,EAAQO,CAAK,EACPA,CACR,CACF,MACEF,EAAUD,EAGZ,OAAOC,CACT,CAEA,SAASG,EACPd,EACAU,EACAD,EACAM,EACA,CACA,IAAIJ,EACJ,GAAI,CACFA,EAAUH,EAAuBC,EAAaC,CAAe,CAC/D,MAAgB,CACd,OAAO,OAAOV,CAAK,CACrB,CAEA,GAAI,CACF,OAAOe,EAAUJ,CAAO,CAC1B,OAASE,EAAO,CACd,OAAAP,EACE,IAAIlB,EAAUC,EAAc,iBAAmBwB,EAAgB,OAAO,CACxE,EACO,OAAOb,CAAK,CACrB,CACF,CAEA,SAASgB,EAEPhB,EAGAU,EACA,CACA,OAAOI,EACLd,EACAU,EACAP,GAAS,SACRQ,IACKJ,GAAY,CAACI,GAAS,WACxBA,EAAU,CAAC,GAAGA,EAAS,SAAAJ,CAAQ,GAG1B,IAAI,KAAK,eAAeH,EAAQO,CAAO,EAAE,OAAOX,CAAK,EAEhE,CACF,CAEA,SAASiB,EACPjB,EACAU,EACA,CACA,OAAOI,EACLd,EACAU,EACAP,GAAS,OACRQ,GAAY,IAAI,KAAK,aAAaP,EAAQO,CAAO,EAAE,OAAOX,CAAK,CAClE,CACF,CAEA,SAASkB,EAEPC,EAEAC,EACA,CACA,GAAI,CACF,GAAI,CAACA,EACH,GAAIf,EACFe,EAAMf,MAEN,OAAM,IAAI,MACR,QAAQ,IAAI,WAAa,aACrB,mGACA,MACN,EAIJ,MAAMgB,EAAWF,aAAgB,KAAOA,EAAO,IAAI,KAAKA,CAAI,EACtDG,EAAUF,aAAe,KAAOA,EAAM,IAAI,KAAKA,CAAG,EAElDtB,GAAWuB,EAAS,QAAQ,EAAIC,EAAQ,QAAQ,GAAK,IACrD,CAAC,KAAArB,EAAM,MAAAD,CAAK,EAAIH,EAA4BC,CAAO,EAEzD,OAAO,IAAI,KAAK,mBAAmBM,EAAQ,CACzC,QAAS,MACX,CAAC,EAAE,OAAOJ,EAAOC,CAAI,CACvB,OAASY,EAAO,CACd,OAAAP,EACE,IAAIlB,EAAUC,EAAc,iBAAmBwB,EAAgB,OAAO,CACxE,EACO,OAAOM,CAAI,CACpB,CACF,CAEA,SAASI,EACPvB,EACAU,EACA,CACA,OAAOI,EAAkBd,EAAOU,EAAiBP,GAAS,KAAOQ,GAC/D,IAAI,KAAK,WAAWP,EAAQO,CAAO,EAAE,OAAOX,CAAK,CACnD,CACF,CAEA,MAAO,CAAC,SAAAgB,EAAU,OAAAC,EAAQ,aAAAC,EAAc,KAAAK,CAAI,CAC9C","names":["IntlError","IntlErrorCode","defaultOnError","MINUTE","HOUR","DAY","WEEK","MONTH","YEAR","getRelativeTimeFormatConfig","seconds","absValue","value","unit","createFormatter","formats","locale","globalNow","onError","timeZone","resolveFormatOrOptions","typeFormats","formatOrOptions","options","formatName","error","getFormattedValue","formatter","dateTime","number","relativeTime","date","now","dateDate","nowDate","list"]}