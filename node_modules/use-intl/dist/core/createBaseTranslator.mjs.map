{"version":3,"sources":["../../src/core/createBaseTranslator.tsx"],"sourcesContent":["// eslint-disable-next-line import/no-named-as-default -- False positive\nimport IntlMessageFormat from 'intl-messageformat';\nimport {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  ReactNodeArray\n} from 'react';\nimport AbstractIntlMessages from './AbstractIntlMessages';\nimport Formats from './Formats';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport TranslationValues, {RichTranslationValues} from './TranslationValues';\nimport convertFormatsToIntlMessageFormat from './convertFormatsToIntlMessageFormat';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\nfunction resolvePath(\n  messages: AbstractIntlMessages | undefined,\n  key: string,\n  namespace?: string\n) {\n  if (!messages) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? `No messages available at \\`${namespace}\\`.`\n        : undefined\n    );\n  }\n\n  let message = messages;\n\n  key.split('.').forEach((part) => {\n    const next = (message as any)[part];\n\n    if (part == null || next == null) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `Could not resolve \\`${key}\\` in ${\n              namespace ? `\\`${namespace}\\`` : 'messages'\n            }.`\n          : undefined\n      );\n    }\n\n    message = next;\n  });\n\n  return message;\n}\n\nfunction prepareTranslationValues(values: RichTranslationValues) {\n  if (Object.keys(values).length === 0) return undefined;\n\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues: RichTranslationValues = {};\n  Object.keys(values).forEach((key) => {\n    let index = 0;\n    const value = values[key];\n\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = (chunks: ReactNode) => {\n        const result = value(chunks);\n\n        return isValidElement(result)\n          ? cloneElement(result, {key: key + index++})\n          : result;\n      };\n    } else {\n      transformed = value;\n    }\n\n    transformedValues[key] = transformed;\n  });\n\n  return transformedValues;\n}\n\nexport function getMessagesOrError<Messages extends AbstractIntlMessages>({\n  messages,\n  namespace,\n  onError = defaultOnError\n}: {\n  messages: Messages;\n  namespace?: string;\n  onError?(error: IntlError): void;\n}) {\n  try {\n    if (!messages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages were configured on the provider.`\n          : undefined\n      );\n    }\n\n    const retrievedMessages = namespace\n      ? resolvePath(messages, namespace)\n      : messages;\n\n    if (!retrievedMessages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages for namespace \\`${namespace}\\` found.`\n          : undefined\n      );\n    }\n\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(\n      IntlErrorCode.MISSING_MESSAGE,\n      (error as Error).message\n    );\n    onError(intlError);\n    return intlError;\n  }\n}\n\nexport type CreateBaseTranslatorProps<Messages> = InitializedIntlConfig & {\n  cachedFormatsByLocale?: Record<string, Record<string, IntlMessageFormat>>;\n  defaultTranslationValues?: RichTranslationValues;\n  namespace?: string;\n  messagesOrError: Messages | IntlError;\n};\n\nexport default function createBaseTranslator<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>({\n  cachedFormatsByLocale,\n  defaultTranslationValues,\n  formats: globalFormats,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}: CreateBaseTranslatorProps<Messages>) {\n  function getFallbackFromErrorAndNotify(\n    key: string,\n    code: IntlErrorCode,\n    message?: string\n  ) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({error, key, namespace});\n  }\n\n  function translateBaseFn(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: RichTranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    let message;\n    try {\n      message = resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n\n    function joinPath(parts: Array<string | undefined>) {\n      return parts.filter((part) => part != null).join('.');\n    }\n\n    const cacheKey = joinPath([namespace, key, String(message)]);\n\n    let messageFormat;\n    if (cachedFormatsByLocale?.[locale]?.[cacheKey]) {\n      messageFormat = cachedFormatsByLocale?.[locale][cacheKey];\n    } else {\n      if (typeof message === 'object') {\n        let code, errorMessage;\n        if (Array.isArray(message)) {\n          code = IntlErrorCode.INVALID_MESSAGE;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages`;\n          }\n        } else {\n          code = IntlErrorCode.INSUFFICIENT_PATH;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages`;\n          }\n        }\n\n        return getFallbackFromErrorAndNotify(key, code, errorMessage);\n      }\n\n      try {\n        messageFormat = new IntlMessageFormat(\n          message,\n          locale,\n          convertFormatsToIntlMessageFormat(\n            {...globalFormats, ...formats},\n            timeZone\n          )\n        );\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INVALID_MESSAGE,\n          (error as Error).message\n        );\n      }\n\n      if (cachedFormatsByLocale) {\n        if (!cachedFormatsByLocale[locale]) {\n          cachedFormatsByLocale[locale] = {};\n        }\n        cachedFormatsByLocale[locale][cacheKey] = messageFormat;\n      }\n    }\n\n    try {\n      const formattedMessage = messageFormat.format(\n        // @ts-ignore `intl-messageformat` expects a different format\n        // for rich text elements since a recent minor update. This\n        // needs to be evaluated in detail, possibly also in regards\n        // to be able to format to parts.\n        prepareTranslationValues({...defaultTranslationValues, ...values})\n      );\n\n      if (formattedMessage == null) {\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Unable to format \\`${key}\\` in ${\n                namespace ? `namespace \\`${namespace}\\`` : 'messages'\n              }`\n            : undefined\n        );\n      }\n\n      // Limit the function signature to return strings or React elements\n      return isValidElement(formattedMessage) ||\n        // Arrays of React elements\n        Array.isArray(formattedMessage) ||\n        typeof formattedMessage === 'string'\n        ? formattedMessage\n        : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.FORMATTING_ERROR,\n        (error as Error).message\n      );\n    }\n  }\n\n  function translateFn<\n    TargetKey extends MessageKeys<\n      NestedValueOf<Messages, NestedKey>,\n      NestedKeyOf<NestedValueOf<Messages, NestedKey>>\n    >\n  >(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: TargetKey,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: TranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string {\n    const result = translateBaseFn(key, values, formats);\n\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.INVALID_MESSAGE,\n        process.env.NODE_ENV !== 'production'\n          ? `The message \\`${key}\\` in ${\n              namespace ? `namespace \\`${namespace}\\`` : 'messages'\n            } didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`\n          : undefined\n      );\n    }\n\n    return result;\n  }\n\n  translateFn.rich = translateBaseFn;\n\n  translateFn.raw = (\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string\n  ): any => {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    try {\n      return resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n  };\n\n  return translateFn;\n}\n"],"mappings":"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","names":["IntlMessageFormat","cloneElement","isValidElement","IntlError","IntlErrorCode","convertFormatsToIntlMessageFormat","defaultGetMessageFallback","defaultOnError","resolvePath","messages","key","namespace","message","part","next","prepareTranslationValues","values","transformedValues","index","value","transformed","chunks","result","getMessagesOrError","onError","retrievedMessages","error","intlError","createBaseTranslator","cachedFormatsByLocale","defaultTranslationValues","globalFormats","getMessageFallback","locale","messagesOrError","timeZone","getFallbackFromErrorAndNotify","code","translateBaseFn","formats","joinPath","parts","cacheKey","messageFormat","errorMessage","formattedMessage","translateFn"]}